---
layout: post
title:  "拜占庭将军问题"
subtitle: ""
date:   2021-2-20 14:37:45 +0800
tags:
  - translate
categories: [translate]
comment: true
---



可靠的计算机系统必须处理出故障的组件给系统其它组件发送冲突信息的情况。这种情况可以抽象地看成一群驻扎在敌人城市周围的拜占庭军队的将军和他们的部队。他们只能够通过信使传递消息，将军们需要协商一个统一的作战计划。但是在这群将军中有一个或多个叛徒，他们会搅乱作战计划。问题就在于需要寻找一种算法，确保忠诚的将军可以统一作战计划。结果表明，只通过`口头信息`沟通，只需要保证忠诚的将军占总将军数的 2/3 以上就能保证作战计划的统一；也就是说 1 个叛徒能够迷惑 2 个忠臣。如果使用`不可伪造的信息`沟通，则任意忠臣和叛徒数都可以保证作战计划的统一。然后再讨论这些解决方法在可靠计算机系统中的应用。



# 1. 简介

一个可靠的计算机系统必须能够容许一个或多个组件的故障。出故障的组件可能会表现出一种容易被人忽略的行为——即，给不同的系统组件发送相互冲突的信息。解决这一类故障问题可以抽象地类比成拜占庭将军问题。

让我们想象一下，多个拜占庭军队驻扎在敌人的城市周围，每个军队都由自己的将军领导，将军们通过信使互相沟通。在观察了敌人的情况后，将军们需要决定出一个统一的行动计划。但是，在这群将军里面可能有一些叛徒，他们会阻止忠诚的将军们达成统一。将军们需要一个算法来保证：

*A. 所有忠诚的将军都决定采用同样的行动计划；*

忠诚的将军们会严格按照算法的指示来行动，但是叛徒则不然。算法必须保证条件 A，无论叛徒怎么做。

忠诚的将军们不仅要达成一致，同样也应该统一一个合理的计划，因此我们还希望：

*B. 少数的叛徒不能使忠诚的将军们采纳一个糟糕的计划；*

条件 B 很难形式化，因为我们没办法明确地判断一个计划的好坏，并且我们也不需要这么做，我们只考虑将军们是如何做出决策（无论是什么计划，我们只希望将军们达成一致）。每个将军都会去观察敌人的情况，并且将他们观察到的情况和其他将军交流。我们用$v(i)$ 来代表第$i$ 个将军传递的信息。每个将军都会使用特定的`模式`将$v(1),...,v(n)$ 的值组合成单一的行动计划，这里的$n$ 代表将军的数量。条件 A 可以通过让所有将军采用相同的`模式`组合信息来达成，而条件 B 可通过采用`健壮的模式`来达成。假设，只需要做进攻或者撤退的决策，那么$v(i)$就是将军$i$的判断，最终的决策基于多数投票产生。只有当忠诚的将军几乎被两种可能的选择平分时，少数的叛徒才可以影响到最终的决策，而且在这种情况下的产生的任意决策也不能说是坏的（==将军们达成了一致，并且此时忠臣们意见平均分成两派，随意选一派意见也是 ok 的==）。

虽然这种方法可能不是满足条件 A 和 B 的唯一方法，但它是我们所知道的唯一方法。在上面的假设中将军们使用一种方式来与其他将军传达$v(i)$值，最显而易见的方法就是第$i$个将军将$v(i)$的值通过信使传达给其它将军。但是，这种方式是行不通的，因为为了满足条件 A，要求所有忠诚的将军拥有相同的$v(1),...,v(n)$值，但是叛徒可能会给不同的将军发送不同的值。为了使条件 A 满足，必须保证：

1. 每个忠诚的将军都必须得到相同的$v(1),...,v(n)$信息。

条件 1 意味着将军们不能直接使用从第$i$位将军那里获取的$v(i)$值，因为，如果第$i$位将军是叛徒，那么他会给不同的将军发送不同的值。也就是说，为了强行满足条件 1，我们可能会遇到将军们要使用的$v(i)$值与第 i 位将军实际发出的值不同的可能性——即使第 i 位将军是忠诚的。如果要满足条件 B，我们绝不能允许这种情况发生。举例来说，我们不能让叛徒使大将军们的决定建立在“撤退”，……，“撤退”上，如果每一个忠诚的将军都发出“进攻”。因此我们需要对每个$i$做如下规定：

2. 如果第$i$位将军是忠诚的，那么每位忠诚的将军都会使用他发送的值作为$v(i)$。

我们重写条件 1 作为每个$i$的条件（无论是否是叛徒）：

1'. 任意两个忠诚的将军使用的$v(i)$相同。

条件 2 和 1'都是对第$i$个将军发送的单个值的约束。



> 在这里有一个隐形条件，即 IC3 当发令官为叛徒时，忠诚的副官们可能都接受或者都拒绝命令（IC1 要求所有忠诚的副官遵循统一的命令）。叛徒副官接受或者拒绝命令都是随心所欲的。

# 2 不可能的结果

